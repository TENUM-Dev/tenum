package ai.tenum.lua.vm.execution

import ai.tenum.lua.runtime.LuaValue
import ai.tenum.lua.runtime.Upvalue
import ai.tenum.lua.vm.OpCode

/**
 * Unified execution environment for opcode handlers.
 *
 * This is the core domain concept that represents the complete runtime environment
 * during bytecode execution. It combines:
 * - Frame state (registers, constants, upvalues, pc, top, varargs)
 * - VM capabilities (metamethods, type operations, error reporting, function calls)
 *
 * ExecutionEnvironment is a composition object created by the VM for each execution,
 * not an interface the VM implements. This maintains proper architectural boundaries:
 * - VM owns the execution lifecycle
 * - ExecutionFrame owns the frame state
 * - ExecutionEnvironment provides unified access to both
 * - Opcode handlers depend only on ExecutionEnvironment
 *
 * This design eliminates:
 * - Data duplication (no executionRegisters in VM mirroring frame.registers)
 * - Inverted dependencies (VM doesn't implement subsystem interfaces)
 * - Unclear ownership (frame state clearly owned by ExecutionFrame)
 */
class ExecutionEnvironment(
    /** The execution frame containing register and frame state */
    val frame: ExecutionFrame,
    /** Global variable table */
    val globals: MutableMap<String, LuaValue<*>>,
    /** VM capabilities delegate */
    private val vmCapabilities: VmCapabilities,
) {
    // Frame state delegation (read-only access to frame internals)
    val registers: MutableList<LuaValue<*>> get() = frame.registers
    val constants: List<LuaValue<*>> get() = frame.constants
    val currentUpvalues: List<Upvalue> get() = frame.upvalues

    /**
     * Safely set a register value, with automatic bounds expansion.
     * Note: This is a workaround for compiler-generated bytecode that exceeds maxStackSize.
     * The proper fix is in the compiler's register allocation.
     */
    fun setRegister(
        index: Int,
        value: LuaValue<*>,
    ) {
        frame.ensureRegisterCapacity(index)
        registers[index] = value
    }

    // VM capabilities delegation
    fun getMetamethod(
        value: LuaValue<*>,
        methodName: String,
    ): LuaValue<*>? = vmCapabilities.getMetamethod(value, methodName)

    fun getRegisterNameHint(registerIndex: Int): String? = vmCapabilities.getRegisterNameHint(registerIndex)

    fun getRegisterNameHint(
        registerIndex: Int,
        pc: Int,
    ): String? = vmCapabilities.getRegisterNameHint(registerIndex, pc)

    fun luaError(message: String): Nothing = vmCapabilities.luaError(message)

    fun error(
        message: String,
        pc: Int,
    ): Nothing = vmCapabilities.error(message, pc)

    fun callFunction(
        func: LuaValue<*>,
        args: List<LuaValue<*>>,
    ): List<LuaValue<*>> = vmCapabilities.callFunction(func, args)

    fun setMetamethodCallContext(metamethodName: String) = vmCapabilities.setMetamethodCallContext(metamethodName)

    fun setPendingInferredName(name: InferredFunctionName?) = vmCapabilities.setPendingInferredName(name)

    fun setNextCallIsCloseMetamethod() = vmCapabilities.setNextCallIsCloseMetamethod()

    fun clearCloseException() = vmCapabilities.clearCloseException()

    fun setCloseException(exception: Exception) = vmCapabilities.setCloseException(exception)

    fun getCloseException(): Exception? = vmCapabilities.getCloseException()

    fun storeCapturedReturnValues(values: List<LuaValue<*>>) {
        // Store captured return values so they survive __close exceptions
        // This is implemented directly since it's specific to LuaVmImpl
        (vmCapabilities as? ai.tenum.lua.vm.LuaVmImpl)?.setCapturedReturnValues(values)
    }

    fun preserveErrorCallStack(callStack: List<ai.tenum.lua.vm.CallFrame>) = vmCapabilities.preserveErrorCallStack(callStack)

    fun markCurrentFrameAsReturning() = vmCapabilities.markCurrentFrameAsReturning()

    fun isTruthy(value: LuaValue<*>): Boolean = vmCapabilities.isTruthy(value)

    fun luaEquals(
        left: LuaValue<*>,
        right: LuaValue<*>,
    ): Boolean = vmCapabilities.luaEquals(left, right)

    fun luaLessThan(
        left: LuaValue<*>,
        right: LuaValue<*>,
    ): Boolean? = vmCapabilities.luaLessThan(left, right)

    fun luaLessOrEqual(
        left: LuaValue<*>,
        right: LuaValue<*>,
    ): Boolean? = vmCapabilities.luaLessOrEqual(left, right)

    fun toNumber(value: LuaValue<*>): Double = vmCapabilities.toNumber(value)

    fun toString(value: LuaValue<*>): String = vmCapabilities.toString(value)

    val debug: (String) -> Unit get() = vmCapabilities.debug

    val trace: (Int, LuaValue<*>, String) -> Unit get() = vmCapabilities.trace

    fun getCallStack(): MutableList<ai.tenum.lua.vm.CallFrame> = vmCapabilities.getCallStack()

    fun replaceLastCallFrame(newFrame: ai.tenum.lua.vm.CallFrame) = vmCapabilities.replaceLastCallFrame(newFrame)

    /**
     * Tracks whether the next function call is a method call (via : syntax).
     * Set by SELF opcode, consumed and cleared by CALL opcode.
     * Used for proper argument numbering in error messages.
     */
    var isMethodCall: Boolean = false

    /**
     * Stores the name hint for method call errors.
     * When SELF returns nil because the object couldn't be indexed (not the method missing),
     * this stores the object's name hint so CALL can report "field 'bbb'" instead of "method 'ddd'".
     * Set by SELF opcode, consumed and cleared by CALL opcode.
     */
    var methodCallErrorHint: String? = null

    /**
     * Stores the global/field name hint for values read by GETTABLE.
     * Maps register index to hint string. This enables correct error messages when
     * the RK limit is exceeded (256+ constants), since backward bytecode analysis
     * becomes unreliable with heavy register reuse.
     * Set by GETTABLE opcode, used by arithmetic/comparison error handlers.
     */
    var gettableResultHints: MutableMap<Int, String> = mutableMapOf()

    /**
     * Get a name hint for a register, preferring runtime GETTABLE hint when available.
     * This solves the RK overflow problem where bytecode analysis becomes unreliable.
     *
     * IMPORTANT: Check for TEST/TESTSET before using runtime hint, because short-circuit
     * operators create computed values that should not have variable name hints, even if
     * the runtime hint was set by GETTABLE earlier.
     */
    fun getRegisterHintWithRuntime(
        registerIndex: Int,
        pc: Int,
    ): String? {
        // FIRST: Check if this register was affected by a TEST/TESTSET short-circuit operator
        // If so, the register contains a computed expression result, not a simple variable
        val proto = frame.proto
        val lookbackStart = maxOf(0, pc - 20) // Look back a few instructions

        // Scan the entire lookback window for TEST/TESTSET
        // The presence of TEST/TESTSET indicates short-circuit evaluation
        for (i in pc - 1 downTo lookbackStart) {
            val instr = proto.instructions.getOrNull(i) ?: continue
            if ((instr.opcode == OpCode.TEST || instr.opcode == OpCode.TESTSET) && instr.a == registerIndex) {
                // Found TEST/TESTSET for this register - it's a computed value
                gettableResultHints.remove(registerIndex)
                return null
            }
        }

        // SECOND: Check runtime hint from GETTABLE
        val runtimeHint = gettableResultHints[registerIndex]
        if (runtimeHint != null) {
            gettableResultHints.remove(registerIndex) // Single-use
            return runtimeHint
        }
        // THIRD: Fall back to bytecode analysis
        return getRegisterNameHint(registerIndex, pc)
    }
}
